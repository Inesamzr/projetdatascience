# Afficher le tableau avec kable
kable(identifiant_counts_filtrees, caption = "Occurrences des Identifiants après Nettoyage")
# Renommer la colonne pour qu'elle corresponde dans les deux dataframes
#donnees_non_recurrentes <- donnees_non_recurrentes %>%
#  rename(salaire_annuel_brut = moyenne_salaire)
#salaire_moyen_individus_recurrents <- salaire_moyen_individus_recurrents %>%
#  rename(salaire_annuel_brut = moyenne_salaire)
# Combiner les deux ensembles de données
donnees_combinees <- bind_rows(salaire_moyen_individus_recurrents, donnees_non_recurrentes)
head(donnees_combinees)
donnees_combinees_filtrees <- donnees_combinees %>%
filter(!is.na(remuneration_annuelle_brute))
head(donnees_combinees_filtrees)
library(knitr)
donnees_combinees_counts <- donnees_combinees_filtrees %>%
count(identifiant, name = "Occurrences")
# Filtrer pour ne montrer que les identifiants avec plus d'une occurrence
identifiants_recurrents_df <- donnees_combinees_counts %>%
filter(Occurrences > 1)
# Afficher le tableau filtré avec kable
kable(identifiants_recurrents_df, caption = "Identifiants récurrents dans donnees_combinees")
library(knitr)
library(dplyr)
# Compter les occurrences des identifiants dans donnees_combinees_filtrees
identifiant_counts_filtrees <- donnees_combinees_filtrees %>%
count(identifiant, name = "Occurrences")
# Affichage tableau
kable(identifiant_counts_filtrees, caption = "Nombre d'occurrences par identifiant dans donnees_combinees_filtrees")
#Statistiques descriptives :
summary(donnees_combinees_filtrees)
library(ggplot2)
ggplot(donnees_combinees_filtrees, aes(x = remuneration_annuelle_brute)) +
geom_histogram(bins = 30, fill = "blue",  color = "black") +
labs(title = "Distribution des Salaires", x = "Salaire Annuel Brut", y = "Fréquence")
#theme_minimal() +
#theme(text = element_text(size = 12))
#ggplot(donnees_non_recurrentes, aes(x = remuneration_annuelle_brute)) +
#  geom_histogram(bins = 40, fill = "blue", color = "black") +
#  scale_x_continuous(
#    breaks = breaks_pretty, # Utiliser les repères générés par pretty()
#    labels = scales::label_comma() # Utiliser label_comma pour un formatage correct des nombres
#  ) +
#  labs(
#    title = "Distribution des Salaires pour les Individus Non Récurrents",
#    x = "Salaire Annuel Brut",
#    y = "Fréquence"
#  ) +
#  theme_minimal() +
#  theme(text = element_text(size = 12))
# Boîte à moustaches pour voir la dispersion et les éventuels outliers
ggplot(donnees_combinees_filtrees, aes(y = remuneration_annuelle_brute)) +
geom_boxplot(outlier.colour = "red", outlier.shape = 1) +
scale_y_continuous(labels = scales::comma) +
labs(title = "Boîte à Moustaches des Salaires genres confondus",
y = "Salaire Annuel Brut") +
theme_minimal() +
theme(
axis.title.y = element_text(size = 12),  # Taille de texte pour les étiquettes des axes
plot.title = element_text(size = 14)  # Taille de texte pour le titre
)
ggplot(donnees_combinees_filtrees, aes(x = sexe, y = remuneration_annuelle_brute)) +
geom_boxplot(outlier.colour = "red", outlier.shape = 1) +
scale_y_continuous(labels = scales::comma) +
labs(title = "Salaires par Genre", x = "Sexe", y = "Salaire Annuel Brut")
# Charger la bibliothèque dplyr pour le traitement des données
library(dplyr)
# Calculer les outliers manuellement
outliers <- donnees_combinees_filtrees %>%
group_by(sexe) %>%
summarize(
lower = quantile(remuneration_annuelle_brute, probs = 0.25) - 1.5 * IQR(remuneration_annuelle_brute),
upper = quantile(remuneration_annuelle_brute, probs = 0.75) + 1.5 * IQR(remuneration_annuelle_brute),
.groups = 'drop'  # Ajouté pour éviter les avertissements dans dplyr 1.0.0 et plus
) %>%
left_join(donnees_combinees_filtrees, by = "sexe") %>%
filter(remuneration_annuelle_brute < lower | remuneration_annuelle_brute > upper)
# Créer le boxplot de base sans outliers
base_plot <- ggplot(donnees_combinees_filtrees, aes(x = sexe, y = remuneration_annuelle_brute)) +
geom_boxplot(outlier.shape = NA) +  # Suppression des outliers dans cette couche
labs(title = "Salaires par Genre", x = "Sexe", y = "Salaire Annuel Brut")
# Ajouter les outliers avec des couleurs spécifiques pour chaque sexe
final_plot <- base_plot +
geom_point(data = outliers, aes(x = sexe, y = remuneration_annuelle_brute, colour = sexe), shape = 1) +
scale_colour_manual(values = c("Homme" = "blue", "Femme" = "red", "Ne souhaite pas répondre" = "grey")) +
theme(legend.position = "none")  # Cache la légende
# Afficher le graphique final
print(final_plot)
library(dplyr)
reponses_par_filiere <- donnees_combinees_filtrees %>%
group_by(filiere) %>%
summarise(Nombre = n()) %>%
ungroup()
library(ggplot2)
ggplot(reponses_par_filiere, aes(x = "", y = Nombre, fill = filiere)) +
geom_bar(width = 1, stat = "identity") +
coord_polar(theta = "y") +  # Coordonnées polaires pour le camembert
theme_void() +  # Thème vide sans axes ni étiquettes
theme(legend.title = element_blank()) +  # Pas de titre pour la légende
labs(title = "Répartition des Réponses par filière", fill = "Filière")  # Nom de la légende
# Compter le nombre de réponses par filière
comptage_filiere <- donnees_combinees_filtrees %>%
group_by(filiere) %>%
summarise(Nombre = n()) %>%
ungroup()
# Créer un graphique à points
ggplot(comptage_filiere, aes(x = filiere, y = Nombre)) +
geom_point(stat = "identity", size = 3) +  # Utilisez size pour ajuster la taille des points
scale_y_continuous(limits = c(0, max(comptage_filiere$Nombre) * 1.1)) +  # Ajuster les limites pour un peu d'espace au-dessus du point le plus haut
coord_flip() + # Pour une meilleure lisibilité, les filières sur l'axe Y et les comptages sur l'axe X
labs(y = "Nombre de Répondants", x = "Filière",
title = "Nombre de Répondants par Filière") +
theme_minimal() +
theme(axis.text.y = element_text(angle = 0, hjust = 1))
# Compter le nombre de réponses par sexe
reponses_par_sexe <- donnees_combinees_filtrees %>%
group_by(sexe) %>%
summarise(Nombre = n()) %>%
ungroup()
# Créer un diagramme en camembert
#ggplot(reponses_par_sexe, aes(x = "", y = Nombre, fill = sexe)) +
#  geom_bar(width = 1, stat = "identity") +
#  coord_polar(theta = "y") +  # Coordonnées polaires pour le camembert
#  theme_void() +  # Thème vide sans axes ni étiquettes
#  theme(legend.title = element_blank()) +  # Pas de titre pour la légende
#  labs(fill = "Sexe")  # Nom de la légende
ggplot(reponses_par_sexe, aes(x = "", y = Nombre, fill = sexe)) +
geom_bar(width = 1, stat = "identity") +
coord_polar(theta = "y") +
theme_void() +
scale_fill_manual(values = c("Femme" = "#EE6677",
"Homme" = "#4477AA",
"Ne souhaite pas répondre" = "grey50")) +
labs(title = "Répartition des Réponses par Genre",
fill = "Sexe") +
theme(legend.title = element_blank())
# Créer un diagramme en barres empilées
ggplot(donnees_combinees_filtrees, aes(x = filiere, fill = sexe)) +
geom_bar(position = "fill") +
scale_y_continuous(labels = scales::percent) +
scale_fill_manual(values = c("Homme" = "#4477AA", "Femme" = "#EE6677", "Ne souhaite pas répondre" = "grey50")) +
labs(x = "Filière", y = "Pourcentage", fill = "Sexe",
title = "Répartition par Sexe au sein de chaque Filière") +
theme_minimal() +
theme(axis.text.x = element_text(angle = 90, vjust = 0.5))
#Normalisation des noms de filières :
donnees_combinees_filtrees <- donnees_combinees_filtrees %>%
mutate(
filiere = case_when(
filiere == "Microélectronique Et Automatique (MEA)" ~ "MEA",
filiere == "MicroÈlectronique Et Automatique (MEA)" ~ "MEA",
filiere == "GÈnie Biologique et Agroalimentaires (GBA)" ~ "GBA",
filiere == "Génie Biologique et Agroalimentaires (GBA)" ~ "GBA",
filiere == "Eau et GÈnie Civil (EGC - apprentissage)" ~ "EGC-app",
filiere == "Eau et Génie Civil (EGC - apprentissage)" ~ "EGC-app",
filiere == "Sciences et Technologies de l'Eau (STE)" ~ "STE",
filiere == "Sciences et Technologies de l Eau (STE)" ~ "STE",
filiere == "Systèmes Embarqués (SE - apprentissage)" ~ "SE-app",
filiere == "SystËmes EmbarquÈs (SE - apprentissage)" ~ "SE-app",
filiere == "Matériaux (MAT)" ~ "MAT",
filiere == "MatÈriaux (MAT)"  ~ "MAT",
filiere == "Mécanique et Interactions (MI)" ~ "MI",
filiere == "MÈcanique et Interactions (MI)" ~ "MI",
filiere == "Informatique et Gestion (IG)"  ~ "IG",
filiere == "Mécanique Structures Industrielles (MSI - apprentissage)" ~ "MSI-app",
filiere == "MÈcanique Structures Industrielles (MSI - apprentissage)" ~ "MSI-app",
filiere == "Energétique - énergies Renouvelables (EnR)" ~ "EnR",
# Ajoutez d'autres correspondances ici
TRUE ~ filiere  # Conserve la valeur actuelle si aucune des conditions ci-dessus n'est remplie
)
)
# Liste des filières uniques
filiere_unique <- unique(donnees_combinees_filtrees$filiere)
# Afficher la liste des filières
print(filiere_unique)
library(dplyr)
reponses_par_filiere <- donnees_combinees_filtrees %>%
group_by(filiere) %>%
summarise(Nombre = n()) %>%
ungroup()
library(ggplot2)
ggplot(reponses_par_filiere, aes(x = "", y = Nombre, fill = filiere)) +
geom_bar(width = 1, stat = "identity") +
coord_polar(theta = "y") +  # Coordonnées polaires pour le camembert
theme_void() +  # Thème vide sans axes ni étiquettes
theme(legend.title = element_blank()) +  # Pas de titre pour la légende
labs(title = "Répartition des Réponses par filière", fill = "Filière")  # Nom de la légende
# Définissez votre palette de couleurs personnalisée (mes_couleurs)
mes_couleurs <- c("#FF5733", "#FFC300", "#C70039", "#900C3F", "#581845","#0074D9","#2ECC40","#B10DC9","#AAAAAA","#EE6677")
ggplot(reponses_par_filiere, aes(x = "", y = Nombre, fill = filiere)) +
geom_bar(width = 1, stat = "identity") +
coord_polar(theta = "y") +
theme_void() +
theme(legend.title = element_blank()) +
labs(title = "Répartition des Réponses par filière", fill = "Filière") +
scale_fill_manual(values = mes_couleurs)  # Utilisation de votre palette de couleurs
#Statistiques descriptives :
summary(donnees_combinees_filtrees)
library(dplyr)
reponses_par_filiere <- donnees_combinees_filtrees %>%
group_by(filiere) %>%
summarise(Nombre = n()) %>%
ungroup()
library(ggplot2)
ggplot(reponses_par_filiere, aes(x = "", y = Nombre, fill = filiere)) +
geom_bar(width = 1, stat = "identity") +
coord_polar(theta = "y") +  # Coordonnées polaires pour le camembert
theme_void() +  # Thème vide sans axes ni étiquettes
theme(legend.title = element_blank()) +  # Pas de titre pour la légende
labs(title = "Répartition des Réponses par filière", fill = "Filière")  # Nom de la légende
# Compter le nombre de réponses par filière
comptage_filiere <- donnees_combinees_filtrees %>%
group_by(filiere) %>%
summarise(Nombre = n()) %>%
ungroup()
# Créer un graphique à points
ggplot(comptage_filiere, aes(x = filiere, y = Nombre)) +
geom_point(stat = "identity", size = 3) +  # Utilisez size pour ajuster la taille des points
scale_y_continuous(limits = c(0, max(comptage_filiere$Nombre) * 1.1)) +  # Ajuster les limites pour un peu d'espace au-dessus du point le plus haut
coord_flip() + # Pour une meilleure lisibilité, les filières sur l'axe Y et les comptages sur l'axe X
labs(y = "Nombre de Répondants", x = "Filière",
title = "Nombre de Répondants par Filière") +
theme_minimal() +
theme(axis.text.y = element_text(angle = 0, hjust = 1))
# Compter le nombre de réponses par sexe
reponses_par_sexe <- donnees_combinees_filtrees %>%
group_by(sexe) %>%
summarise(Nombre = n()) %>%
ungroup()
# Créer un diagramme en camembert
#ggplot(reponses_par_sexe, aes(x = "", y = Nombre, fill = sexe)) +
#  geom_bar(width = 1, stat = "identity") +
#  coord_polar(theta = "y") +  # Coordonnées polaires pour le camembert
#  theme_void() +  # Thème vide sans axes ni étiquettes
#  theme(legend.title = element_blank()) +  # Pas de titre pour la légende
#  labs(fill = "Sexe")  # Nom de la légende
ggplot(reponses_par_sexe, aes(x = "", y = Nombre, fill = sexe)) +
geom_bar(width = 1, stat = "identity") +
coord_polar(theta = "y") +
theme_void() +
scale_fill_manual(values = c("Femme" = "#EE6677",
"Homme" = "#4477AA",
"Ne souhaite pas répondre" = "grey50")) +
labs(title = "Répartition des Réponses par Genre",
fill = "Sexe") +
theme(legend.title = element_blank())
# Créer un diagramme en barres empilées
ggplot(donnees_combinees_filtrees, aes(x = filiere, fill = sexe)) +
geom_bar(position = "fill") +
scale_y_continuous(labels = scales::percent) +
scale_fill_manual(values = c("Homme" = "#4477AA", "Femme" = "#EE6677", "Ne souhaite pas répondre" = "grey50")) +
labs(x = "Filière", y = "Pourcentage", fill = "Sexe",
title = "Répartition par Sexe au sein de chaque Filière") +
theme_minimal() +
theme(axis.text.x = element_text(angle = 90, vjust = 0.5))
# Créer un graphique à facettes
ggplot(donnees_combinees_filtrees, aes(x = sexe, fill = sexe)) +
geom_bar() +
facet_wrap(~filiere) +
labs(x = "Sexe", y = "Nombre de Répondants", fill = "Sexe",
title = "Nombre de Répondants par Sexe et par Filière") +
theme_minimal() +
theme(legend.position = "bottom", strip.text.x = element_text(angle = 90))
library(ggplot2)
ggplot(donnees_combinees_filtrees, aes(x = filiere, y = remuneration_annuelle_brute)) +
geom_boxplot(outlier.colour = "black", outlier.shape = 1) +
theme(axis.text.x = element_text(angle = 90, hjust = 1)) +  # Incliner les étiquettes de l'axe x si elles sont trop longues
labs(title = "Boxplot de la Rémunération Annuelle Brute par Filière",
x = "Filière",
y = "Rémunération Annuelle Brute") +
theme_minimal()
#Normalisation des noms de filières :
donnees_combinees_filtrees <- donnees_combinees_filtrees %>%
mutate(
filiere = case_when(
filiere == "Microélectronique Et Automatique (MEA)" ~ "MEA",
filiere == "MicroÈlectronique Et Automatique (MEA)" ~ "MEA",
filiere == "GÈnie Biologique et Agroalimentaires (GBA)" ~ "GBA",
filiere == "Génie Biologique et Agroalimentaires (GBA)" ~ "GBA",
filiere == "Eau et GÈnie Civil (EGC - apprentissage)" ~ "EGC-app",
filiere == "Eau et Génie Civil (EGC - apprentissage)" ~ "EGC-app",
filiere == "Sciences et Technologies de l'Eau (STE)" ~ "STE",
filiere == "Sciences et Technologies de l Eau (STE)" ~ "STE",
filiere == "Systèmes Embarqués (SE - apprentissage)" ~ "SE-app",
filiere == "SystËmes EmbarquÈs (SE - apprentissage)" ~ "SE-app",
filiere == "Matériaux (MAT)" ~ "MAT",
filiere == "MatÈriaux (MAT)"  ~ "MAT",
filiere == "Mécanique et Interactions (MI)" ~ "MI",
filiere == "MÈcanique et Interactions (MI)" ~ "MI",
filiere == "Informatique et Gestion (IG)"  ~ "IG",
filiere == "Mécanique Structures Industrielles (MSI - apprentissage)" ~ "MSI-app",
filiere == "MÈcanique Structures Industrielles (MSI - apprentissage)" ~ "MSI-app",
filiere == "Energétique - énergies Renouvelables (EnR)" ~ "EnR",
# Ajoutez d'autres correspondances ici
TRUE ~ filiere  # Conserve la valeur actuelle si aucune des conditions ci-dessus n'est remplie
)
)
# Liste des filières uniques
filiere_unique <- unique(donnees_combinees_filtrees$filiere)
# Afficher la liste des filières
print(filiere_unique)
library(dplyr)
reponses_par_filiere <- donnees_combinees_filtrees %>%
group_by(filiere) %>%
summarise(Nombre = n()) %>%
ungroup()
library(ggplot2)
ggplot(reponses_par_filiere, aes(x = "", y = Nombre, fill = filiere)) +
geom_bar(width = 1, stat = "identity") +
coord_polar(theta = "y") +  # Coordonnées polaires pour le camembert
theme_void() +  # Thème vide sans axes ni étiquettes
theme(legend.title = element_blank()) +  # Pas de titre pour la légende
labs(title = "Répartition des Réponses par filière", fill = "Filière")  # Nom de la légende
ggplot(donnees_combinees_filtrees, aes(x = filiere, y = remuneration_annuelle_brute, fill = filiere)) +
geom_boxplot(outlier.colour = "black", outlier.shape = 1) +
scale_fill_brewer(palette = "Paired") +  # Choisissez une palette de couleurs
theme(axis.text.x = element_text(angle = 90, hjust = 1)) +  # Incliner les étiquettes de l'axe x si elles sont trop longues
labs(title = "Boxplot de la Rémunération Annuelle Brute par Filière",
x = "Filière",
y = "Rémunération Annuelle Brute") +
theme_minimal()
ggplot(donnees_combinees_filtrees, aes(x = filiere, y = remuneration_annuelle_brute, fill = filiere)) +
geom_boxplot(outlier.colour = "black", outlier.shape = 1) +
scale_fill_manual(values = c("GBA" = "chartreuse3", "IG" = "deeppink1", "MEA" = "plum", "STE" = "deepskyblue3",
"MI"="salmon3", "SE-app"="skyblue3", "MSI-app"="lightsteelblue", "MAT"="lightseagreen", "EnR"="wheat1", "EGC-app"="sienna1")) +  # Définir les couleurs manuellement
theme(axis.text.x = element_text(angle = 90, hjust = 1)) +  # Incliner les étiquettes de l'axe x si elles sont trop longues
labs(title = "Boxplot de la Rémunération Annuelle Brute par Filière",
x = "Filière",
y = "Rémunération Annuelle Brute") +
theme_minimal() +
theme(legend.position = "none")
ggplot(donnees_combinees_filtrees, aes(x = filiere, y = remuneration_annuelle_brute)) +
geom_boxplot(aes(fill = sexe), position = position_dodge(0.8), outlier.colour = "black", outlier.shape = 1) +
scale_fill_manual(values = c("Femme" = "#EE6677", "Homme" = "#4477AA", "Ne souhaite pas répondre" = "grey50")) +
theme(axis.text.x = element_text(angle = 90, hjust = 1, vjust = 0.5)) +
labs(title = "Boxplot de la Rémunération Annuelle Brute par Filière et Sexe",
x = "Filière",
y = "Rémunération Annuelle Brute") +
theme_minimal() +
theme(legend.position = "bottom")  # Placez la légende en bas pour économiser de l'espace
ggplot(donnees_combinees_filtrees, aes(x = filiere, y = remuneration_annuelle_brute)) +
geom_boxplot(aes(fill = sexe), position = position_dodge(0.8), outlier.colour = "black", outlier.shape = 1) +
scale_fill_manual(values = c("Femme" = "#EE6677", "Homme" = "#4477AA", "Ne souhaite pas répondre" = "grey50")) +
theme(axis.text.x = element_text(angle = 90, hjust = 1, vjust = 0.5)) +
labs(title = "Boxplot de la Rémunération Annuelle Brute par Filière et Sexe",
x = "Filière",
y = "Rémunération Annuelle Brute") +
theme_minimal() +
theme(legend.position = "bottom") +
scale_y_continuous(breaks = seq(0, 100000, by = 10000), labels = comma, limits = c(0, 100000))
# Vérifier les niveaux uniques pour la nationalité française
unique(donnees_combinees_filtrees$nationalite_francaise)
# Vérifier les niveaux uniques pour toutes les nationalités
unique(donnees_combinees_filtrees$nationalite)
# Compter le nombre de réponses par catégorie de nationalité française
reponses_nationalite <- donnees_combinees_filtrees %>%
mutate(nationalite_francaise = ifelse(nationalite_francaise == "", "Pas de réponse", nationalite_francaise)) %>%
count(nationalite_francaise) %>%
ungroup()
# Créer un diagramme en barres
ggplot(reponses_nationalite, aes(x = nationalite_francaise, y = n, fill = nationalite_francaise)) +
geom_bar(stat = "identity") +
labs(x = "Nationalité Française", y = "Nombre de Répondants",
title = "Nombre de Répondants par Statut de Nationalité Française") +
scale_fill_brewer(palette = "Set1") +
theme_minimal() +
theme(axis.text.x = element_text(angle = 45, hjust = 1))
# Créer un diagramme en camembert
ggplot(reponses_nationalite, aes(x = "", y = n, fill = nationalite_francaise)) +
geom_bar(width = 1, stat = "identity") +
coord_polar(theta = "y") +
labs(fill = "Nationalité Française",
title = "Proportion des Répondants par Statut de Nationalité Française") +
scale_fill_brewer(palette = "Set1") +
theme_void() +
theme(legend.title = element_blank(), legend.position = "bottom")
# Calculer la moyenne des salaires par catégorie de nationalité française
moyenne_salaire_par_nationalite <- donnees_combinees_filtrees %>%
group_by(nationalite_francaise) %>%
summarise(moyenne_salaire = mean(remuneration_annuelle_brute, na.rm = TRUE)) %>%
ungroup()
# Créer un graphique à barres des moyennes
ggplot(moyenne_salaire_par_nationalite, aes(x = nationalite_francaise, y = moyenne_salaire, fill = nationalite_francaise)) +
geom_bar(stat = "identity", position = "dodge") +
labs(x = "Nationalité Française", y = "Salaire Annuel Brut Moyen", title = "Salaire Annuel Brut Moyen par Nationalité Française") +
scale_fill_brewer(palette = "Set1") +
theme_minimal() +
theme(axis.text.x = element_text(angle = 45, hjust = 1))
ggplot(donnees_combinees_filtrees, aes(x = nationalite_francaise, y = remuneration_annuelle_brute, fill = nationalite_francaise)) +
geom_boxplot() +
labs(x = "Nationalité Française", y = "Salaire Annuel Brut", title = "Distribution du Salaire Annuel Brut par Nationalité Française") +
scale_fill_brewer(palette = "Set1") +
theme_minimal() +
theme(axis.text.x = element_text(angle = 45, hjust = 1))
donnees_nettoyees_nationalite <- donnees_combinees_filtrees %>%
mutate(nationalite_francaise = ifelse(nationalite_francaise == "", "Inconnue", nationalite_francaise)) %>%
# Vous pouvez également choisir d'exclure les lignes avec des valeurs vides
filter(nationalite_francaise != "Inconnue")
# Calculer la moyenne des salaires par catégorie de nationalité française
moyenne_salaire_par_nationalite <- donnees_nettoyees_nationalite %>%
group_by(nationalite_francaise) %>%
summarise(moyenne_salaire = mean(remuneration_annuelle_brute, na.rm = TRUE)) %>%
ungroup()
# Créer un graphique à barres des moyennes
ggplot(moyenne_salaire_par_nationalite, aes(x = nationalite_francaise, y = moyenne_salaire, fill = nationalite_francaise)) +
geom_bar(stat = "identity", position = "dodge") +
labs(x = "Nationalité Française", y = "Salaire Annuel Brut Moyen", title = "Salaire Annuel Brut Moyen par Nationalité Française") +
scale_fill_brewer(palette = "Set1") +
theme_minimal() +
theme(axis.text.x = element_text(angle = 45, hjust = 1))
ggplot(donnees_nettoyees_nationalite, aes(x = nationalite_francaise, y = remuneration_annuelle_brute, fill = nationalite_francaise)) +
geom_boxplot() +
labs(x = "Nationalité Française", y = "Salaire Annuel Brut", title = "Distribution du Salaire Annuel Brut par Nationalité Française") +
scale_fill_brewer(palette = "Set1") +
theme_minimal() +
theme(axis.text.x = element_text(angle = 45, hjust = 1))
# Compter le nombre de réponses par catégorie de nationalité française dans donnees_nettoyees
reponses_nationalite_nettoyees <- donnees_nettoyees_nationalite %>%
count(nationalite_francaise) %>%
ungroup()
# Créer un diagramme en barres pour donnees_nettoyees
ggplot(reponses_nationalite_nettoyees, aes(x = nationalite_francaise, y = n, fill = nationalite_francaise)) +
geom_bar(stat = "identity") +
labs(x = "Nationalité Française", y = "Nombre de Répondants",
title = "Nombre de Répondants par Statut de Nationalité Française dans les Données Nettoyées") +
scale_fill_brewer(palette = "Set1") +
theme_minimal() +
theme(axis.text.x = element_text(angle = 45, hjust = 1))
# Créer un diagramme en camembert pour donnees_nettoyees
ggplot(reponses_nationalite_nettoyees, aes(x = "", y = n, fill = nationalite_francaise)) +
geom_bar(width = 1, stat = "identity") +
coord_polar(theta = "y") +
labs(fill = "Nationalité Française",
title = "Proportion des Répondants par Statut de Nationalité Française dans les Données Nettoyées") +
scale_fill_brewer(palette = "Set1") +
theme_void() +
theme(legend.title = element_blank(), legend.position = "bottom")
# Exporter vers un fichier CSV
write.csv(donnees_combinees_filtrees, file = "donnees_combinees_filtrees.csv", row.names = FALSE)
# Assure-toi que le package ggplot2 est installé et chargé
if (!require(ggplot2)) install.packages("ggplot2")
library(ggplot2)
# Utilisation de ggplot2 pour créer un boxplot
ggplot(donnees_combinees_filtrees, aes(x = nationalite, y = remuneration_annuelle_brute)) +
geom_boxplot(outlier.colour = "red", outlier.shape = 1) +
labs(title = "Répartition des Salaires selon la Nationalité",
x = "Nationalité",
y = "Salaire Annuel Brut") +
theme_minimal() +
theme(axis.text.x = element_text(angle = 45, hjust = 1))
# Pour chaque filière, calculer les quartiles et la médiane
quartiles_medianes <- donnees_combinees_filtrees %>%
group_by(filiere) %>%
summarise(
Q1 = quantile(remuneration_annuelle_brute, 0.25, na.rm = TRUE),
Mediane = median(remuneration_annuelle_brute, na.rm = TRUE),
Q3 = quantile(remuneration_annuelle_brute, 0.75, na.rm = TRUE)
)
# Afficher les résultats
print(quartiles_medianes)
#Normalisation des noms de filières :
donnees_combinees_filtrees <- donnees_combinees_filtrees %>%
mutate(
nationalite = case_when(
nationalite == "Burkinabé" ~ "Burkinabé",
nationalite == "BURKINABE" ~ "Burkinabé",
nationalite == "Burkinabe" ~ "Burkinabé",
nationalite == "Péruvienne" ~ "Péruvienne",
nationalite == "Péruvienne " ~ "Péruvienne",
nationalite == "Senegalaise" ~ "Senegalaise",
nationalite == "Sénégal" ~ "Senegalaise",
nationalite == "BrÈsilienne" ~ "Brésilienne",
nationalite == "Brésilien" ~ "Brésilienne",
nationalite == "Brésilienne" ~ "Brésilienne",
nationalite == "AlgÈrienne" ~ "Algérienne",
nationalite == "Algérienne" ~ "Algérienne",
nationalite == "Malienne "  ~ "Malienne",
nationalite == "Cameroun "  ~ "Camerounaise",
TRUE ~ nationalite  # Conserve la valeur actuelle si aucune des conditions ci-dessus n'est remplie
)
)
# Liste des filières uniques
nationalite_unique <- unique(donnees_combinees_filtrees$nationalite)
# Afficher la liste des filières
print(nationalite_unique)
library(dplyr)
# Pour chaque nationalité, calculer les quartiles et la médiane
quartiles_medianes_nationalite <- donnees_combinees_filtrees %>%
group_by(nationalite) %>%
summarise(
Q1 = quantile(remuneration_annuelle_brute, 0.25, na.rm = TRUE),
Mediane = median(remuneration_annuelle_brute, na.rm = TRUE),
Q3 = quantile(remuneration_annuelle_brute, 0.75, na.rm = TRUE)
)
# Afficher les résultats
print(quartiles_medianes_nationalite)
# Créer un diagramme en camembert pour donnees_nettoyees
ggplot(reponses_nationalite_nettoyees, aes(x = "", y = n, fill = nationalite_francaise)) +
geom_bar(width = 1, stat = "identity") +
coord_polar(theta = "y") +
labs(fill = "Nationalité Française",
title = "Proportion des Répondants par Statut de Nationalité Française") +
scale_fill_brewer(palette = "Set1") +
theme_void() +
theme(legend.title = element_blank(), legend.position = "bottom")
shiny::runApp('Desktop/projetdatascience/Application/Application')
shiny::runApp('Desktop/projetdatascience/Application/Application')
rsconnect::deployApp("C:\\Users\\gouda\\OneDrive\\Documents\\INFO4A Montpellier\\projetdatascience\\Application\\Application")
system("git pull")
system("git ")
system("git pull")
cd ..
cd..
